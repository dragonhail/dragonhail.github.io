---
title: Network
weight: 1
---
### Protocol
- 통신을 수행하는 규악

### OSI 7 계층
- 프로토콜이 아님
- 네트워크의 통신 계층을 7개의 계층으로 나누는 개념적 프레임워크
- 이점
  - 복잡한 시스템에 대한 이해 공유
  - 엔지니어가 작업을 이해하기 쉬워서 빠른 연구 및 개발이 가능

### 계층
#### Physical Layer(물리 계층)
- 물리적 통신 매체를 통해 전송하는 기술
- 케이블이나 Bluetooth, NFC, 데이터 전송 속도가 포함된 영역 

#### Datalink Layer
- 물리 계층이 이미 존재하는 네트워크를 통해 두 시스템을 연결하는데 사용

#### Network Layer
- 분산된 네트워크 하나 또는 연결된 여러 네트워크의 노드 또는 머신을 통한 라우팅 또는 전달 및 주소 지정

#### Transport Layer
- 데이터 전송, 순서 제어나 오류 제어 등을 수행

#### Session Layer
- 동기화 작업

#### Presentation Layer
- 데이터 표현, 압축, 암호화

#### Application Layer
- 사용자가 사용하는 특정 유형의 애플리케이션의 통신 방법
- https, ftp, smtp 등

### MAC
- Media Access Control Address
- 데이터 링크 계층에서 사용하는 주소 체계
- 하드웨어에 장착된 네트워크 인터페이스 카드의 고유한 이름
- 이더넷과 와이파이가 이 주소를 사용

### IP주소
- 인터넷을 이용하는 네트워크에서 컴퓨터를 구분하기 위한 주소 체계
- IPv4: 32비트 주소 체계, 8비트씩 묶어서 10진수 형태로 사용
  - 사용주소범위는 0.0.0.0 - 255.255.255.255
  - A 클래스: 0.0.0.0 - 127.255.255.255
  - B 클래스: 앞의 두개가 10으로 시작하는 것
    - 128.0.0.0 - 191.255.255.255
  - C 클래스: 앞의 세개가 110으로 시작하는 것
    - 192.0.0.0 - 223.255.255.255
  - D 클래스: 앞의 네개가 1110으로 시작하는 것
    - 224.0.0.0 - 239.255.255.255
  - E 클래스: 앞의 4개가 1111로 시작하는 것
    - 240.0.0.0 - 255.255.255.255
- 통신분류방식
  - 유니캐스트: 1:1 통식
  - 멀티캐스트: 그룹과의 통신
  - 브로드캐스트: 전체와 통신
  - 애니캐스트: 아무나 하나

### IPv6
- 128비트주소
- IPv6의 주소 고갈 문제를 해결하기 위해서 등장한 방식
- 현재는 IPv6를 사용하고 있음
- IPv4주소를 설정하면 네트워크 장비를 통해 외부로 전송이 될 때 IPv6로 변환되어서 전송
- 하나의 블럭에서 모두 동일한 값이면 하나로 줄여서 쓰는 것이 가능
- 모두 0인 블럭은 생략도 가능

### Loopback
- 자기 자신을 가리키기 위해 만들어진 IP 주소
- 현재 조작 중인 컴퓨터를 네트워크 연결 대상으로 인지하기 위해 만들어낸 주소
- IPv4에서는 127.0.0.1 ~ 127.255.255.255 이고 IPv6에서는 ::1(0::0::0::0::0::0::1)
- 운영체제 내부의 설정 파일에 localhost=127.0.0.1이라고 작성했기 때문에 localhost라고 하면 현재 컴퓨터에 접근하는 것, 리눅스에서는 /etc/hosts 파일에 연결되있음

### Private IP
- 대역
- A Class - 10.0.0.0 ~ 10.255.255.255
- B Class - 172.31.255.255
- C Class - 192.168.0.0 ~ 192.168.255.255
- 내부 네트워크 구성을 위해 사용하는 IP
- 이 IP를 가지고 인터넷에 직접 연결할 수 없음
- 최근에는 보안 그리고 IP를 유동으로 할당하기 위해서 사용

### 유동IP와 고정IP

### 동일한 네트워크
- 통신이 가능한 대역의 IP를 가지고 있어야 함

### subnet mask
- 네트워크 규모를 나타내기 위한 마스크
- 32비트 표시
- 맨 앞에서부터 연속된 1까지의 IP가 같으면 동일 네트워크로 간주해서 라우터를 통해서 외부로 나가지 않고 통신이 가능하도록 해줌

```bash
IP -> 0.0.0.7
subnet mask -> 255.255.0.0

0.0.0.7과 0.0.1.23이 통신을 할 때는 라우터를 통해 외부로 나가지 않고 외부로 통신 가능
```
- IPv4의 주소가 192.168.202.207이고 서브넷 마스크가 255.255.255.0임
- 제 컴퓨터와 라우터가 연결없이 통신할 수 있는 주소 대역은 192.168.202.0 ~ 192.168.202.255
- 이 IP 대역을 네트워크라고 함
- 동일 네트워크 대역을 표현할 때 서브넷 마스크를 이용하기도 하지만 비트수를 이용하기도함
- IP주소 뒤에 / 를 하고 일치해야 하는 비트수 작성
- IPv4의 주소가 192.168.202.207이고 서브넷 마스크가 255.255.255.0 표현을 192.168.202.207/24 로 표현
- 네트워크 대역으로 IP주소를 표현하면 일치해야 하는 부분을 네트워크, 일치하지 않아도 되는 부분 호스트
  - 192.168.202가 네트워크, 207이 호스트
  - 192.168.0.1/24 192.168.0.2/24 -> 24만 같으면 같은 네트워크, 외부로 나갈 필요없음
  - 192.168.0.1/32 192.168.0.2/32 -> 다른 네트워크, 외부로 나가야
- Public Cloud에서 같은 네트워크면 과금없음, 다른 네트워크면 과금 -> 같은 VPC로 설정해야함
- 하나의 네트워크 대역에서 할당할 수 있는 주소의 개수는 (주소의개수 -2)
- 시작, 끝 번호는 사용불가
- 시작 주소는 외부에서 이 네트워크 찾아오기 위한 대표주소, 마지막 주소는 broadcast 위한 주소
- broadcast는 전체와 통신을 하는 것
- 라우터에 IP하나 부여되고 동적 사설IP가 타임 쉐어링 방식으로 빠르게 교환
```bash
예)
IP: 192.168.202.207 -> b(202) = 11001010 
서브넷마스크: 255.255.252.0 -> b(252) = 11111100

범위 -> 192.168.200.0 ~ 192.168.203.255
대표주소 -> 192.168.200.0 (첫번째주소)
브로드캐스팅주소 -> 192.168.203.255 (마지막주소)
게이트웨이주소 -> 192.168.200.1 (대표주소와 브로드캐스팅 주소를 제외한 주소중 첫째나 마지막 주소로 관습적 부여, 설정하는 사람 마음)
즉 총IP개수: 3*256개
사용가능 IP개수: 3*256-2-1개
```

- Gateway: 외부 네트워크와 통신하기 위해서 내부 네트워크에서 접근해야 할 곳
  - 네트워크 장비와 연결되는 지점
  - 반드시 그런 것은 아니지만 주소 할당을 할 때 대표주소와 브로드캐스팅 주소를 제외한 주소중 첫째나 마지막 주소로 관습적 부여
- Default Subnet Mask: 서브넷 마스크를 설정하지 않으면 자동으로 설정되는 서브넷 마스크
  - A Class: 255.0.0.0
  - B Class: 255.255.0.0
  - C Class: 255.255.255.0

### 네트워크 수 계산
- 기업 내부에 네트워크 수를 계산하는 가장 쉬운 방법은 라우터를 기반으로 하는 것
- 라우터 장비만 네트워크를 분할 할 수 있음
- 라우터 장비와 연결된 하나의 회선은 항상 별도의 네트워크임
- 네트워크 수에 따라 IP 주소 대역이 서로 달라져야 함
- 이 작업은 인프라를 직접 구성할 때 필요함
- 라우터와 스위치: 라우터는 네트워크를 구분할 수 있지만 스위치는 네트워크를 분류 못함
- 최근에는 스위치의 기능을 라우터까지 확장해서 출시
- L3 Switch, L4 Switch 라 불리는데 L3가 라우터를 의미
- L3는 물리적으로 네트워크 분리, L2는 논리적으로 분리, L1은 증폭기 기능

### 라우팅
- 3계층의 주소를 보고 목적지로 전송하기 위한 경로를 설정하는 것
- IP주소는 서브넷 마스크를 이용해서 주소를 계층을 만든 것
- MAC ADDRESS는 주소 계층이 없음
- 계층이 없는 주소를 Flat Address

### 이더넷 스위칭
- 하나의 물리적인 네트워크 안에서 다시 네트워크를 분할하고자 할 때 라우터를 이용하지 않고 스위치를 이용해 분할
- 논리적으로 분할된 네트워크를 세그먼트라고 함
- 스위치는 세그먼트를 분할하기 위한 장비
- 스위치는 포트 별로 세그먼트를 분할할 수 있는 실제 스위치에서 이렇게 분할한 네트워크를 VLAN이라고 함

### 실제 구축
- 2중화를 해서 구축하는 것이 좋음(장애 대비, 부하 분산)
- 라우터와 스위치를 적절히 배치해서 트래픽을 분산해야 하고 이를 기반으로 bandwidth를 산정해 네트워크 구성을 해야

### 응용계층 프로토콜
- 실제 서비스와 관련된 프로토콜: 인간이 사용하는 서비스와 관련된 프로토콜
- 인터넷 관련 프로토콜
  - TCP: 연결형 프로토콜, 신뢰성높음, HTTPS
  - UDP: 비연결형 프로토콜, 전송속도빠름, datagram방식, DNS, NTMP, Apple의 APNS와 Google의 FCM
    ```bash
    스마트폰 푸쉬구조: 
    스마트폰->카카오서버->구글/애플서버->스마트폰
    스마트폰 IP 계속바뀌기 때문에 구글/애플서버에서 쏘아줌
    ```

### VLAN
- 하나의 물리적인 네트워크를 논리적으로 분할하는 것
- IP주소와 서브넷마스크를 이용해 분할
- 논리적으로 분할하게 되면 내부통신으로는 접근할 수 없음
- 스위치와 같은 장비로 분할하면 트래픽도 전달이 안됨
- IP와 서브넷 마스크 이용해 장비 없이도 가능
- cloud 환경에서 여러컴퓨터를 논리적으로 묶고자 할 때 이 개념을 사용
- 서버, 데이터서버, API서버, Application Server 등을 하나의 VLAN으로 묶어서 통신이 가능하도록 하고 외부로 노출시켜야 하는 컴퓨터만 퍼블릭 설정을 해 보안을 강화하고 트래픽을 최소로 사용하도록 설계

`192.168.0.0/24 -> 192.168.0.0/25 192`

### NAT Overload
- Dynamic NAT만으로는 publicIP 차단 효과 미비
- 컴퓨터의 애플리케이션은 특정 컴퓨터의 서비스를 이용할 목적으로 만들어짐
- 컴퓨터 애플리케이션은 컴퓨터에 접속 후 자신이 원하는 프로세스 또는 서비스에 요청전송
- 컴퓨터에서는 이렇게 프로세스를 구분하기 위한 PID(프로세스ID)를 사용하는데 외부 컴퓨터에서 접속 할 때는 PID를 이용해서 서비스를 찾지 않고 port의 개념을 이용해서 원하는 서비스를 요청
- 네트워크 장비에서 내부 네트워크의 컴퓨터 구별할 때 IP만 사용하는 것이 아니라 포트까지 이용해서 구별하게 되면 훨씐 더 많은 컴퓨터를 내부 네트워크에서 사용하는 것이 가능해짐
- NAT Overload라고 하기도 하고 PAT(Port Address Translation) 라고도 함

### NAT를 사용하는 환경에서 NAT 내부의 컴퓨터를 서버로 사용하고자 하는 경우
- 네트워크 장비에 들어가서 외부 IP와 포트에 내부 장비의 IP와 포트가 고정되서 변환이 되도록 해주면 됨
- 외부 IP를 이용해서 내부 컴퓨터에 접속 가능

### Access List
* 라우터 또는 컴퓨터를 통과하는 패킷 중 불필요하거나 나쁜 의도를 가진 패킷을 차단하기 위해서 작성
* 종류:
  * Standard Access List: 패킷의 허용 및 차단 기준이 출발지 IP
  * Extended Access List: 패킷의 허용 및 차단의 기준이 출발지 IP, 목적지 IP 주소, 프로토콜, 포트 번호 4가지
* 운영체제 내부에서는 일반적으로 포트 번호만 기재해서 방화벽에서 해제하고 차단하는데 이 경우는 permit all 또는 deny all

### Standard Access List
- permit이나 deny IP주소 와일드카드마스크(서브넷 마스크 반대 - 반드시 일치하는 것이 0, 일치하지 않아도 되는 것이 1)
  - 11.1.1.0/24 네트워크를 허용 -> ```permit 11.1.1.0 0.0.0.255```
  - permit any나 deny any를 이용하면 전체를 허용하거나 거부하는 것이 가능
  - 여러 줄로 작성하는 것이 가능, 위에서부터 순차적으로 적용
```
ex
- 11.1.1.0/24 네트워크에서 11.1.1.1 에 해당하는 컴퓨터만 허용하고 나머지는 모두 거부
- 그 이외 네트워크는 모두 허용(permit any나 deny any가 앞에 있으면 안됨, 위쪽이 작은 규모, 아래쪽으로 갈 수록 큰 규모)
- permit any나 deny any
=>
permit 11.1.1.1 0.0.0.0 (0.0.0.0 대신에 permit 다음에 host 라고 하면 이 경우도 하나의 컴퓨터)
deny 11.1.1.0 0.0.0.255
permit any
```

### Extended Access List
- permit 이나 deny를 먼저 쓰고 tcp | udp | ip 소스네트워크 목적지네트워크 [포트조건]
```
ex)
11.1.1.0/24 네트워크에서 11.1.2.0/24 네트워크로 향하는 20번 포트만 거부
=>
deny tcp 11.1.1.0 0.0.0.255 11.1.2.0 0.0.0.255 eq 20
```
- 모든 트래픽 허용 ```permit ip any any```
- 기억해야 할 포트: FTP->20/21 TELNET->23 SMTP(메일)->25 DNS->53 HTTP->80 HTTPS->443
- 실습
```
FTP는 파일 전송 프로토콜인데 TCP 서비스이고 포트번호는 20번과 21번 사용
11.1.1.0/24 네트워크가 파일 전송 하는 것을 금지시키고자 함
Access List에 어떻게 적어야 한가
=>
deny tcp 11.1.1.0 0.0.0.255 any eq 20
deny tcp 11.1.1.0 0.0.0.255 any eq 21
permit ip any any
```

### 네트워크 구성도
- 홈 네트워크 
  - 인터넷 <-> 모뎀 <-> 공유기 <-> 컴퓨터, 테블릿, 스마트폰
- 데이터 센터 네트워크
  - 안정적이고 빠른 대용량 서비스 제공을 목표로 함
  - 구성 방법
    - 3계층 디자인 - 예전에 많이 사용하던 방식
    - Core <-> Aggregation(속도, 흐름제어) <-> Access
    - 2계층 디자인 - 최근에 네트워크 속도가 빨라지면서 사용, Spine-Leaf 구조

### 프로토콜
- 통신을 하기 위한 규칙 규약
- 물리적 측면: 데이터 전송 매체 (케이블), 신호 규약, 회선 규격 등을 정의하는 것인데 최근에는 거의 이더넷만 사용
- 논리적 측면: 프로토콜 규격 등을 정의하는 것인데 최근에는 TCP/IP만 사용
- 프로토콜을 정의할 때 예전에는 비트 기반으로 많이 만들었는데 최근에는 문자 기반으로 많이 사용
  - 비트 기반의 프로토콜은 효율적이긴 하지만 사람이 읽기 어려움
- TCP/IP는 엄밀한 의미에서는 프로토콜이 아니고 프로토콜 스택
  - TCP와 IP는 별도의 계층에서 동작하는 프로토콜인데 이를 합쳐서 부름
  - TCP/IP 이외에도 UDP, ICMP, ARP, HTTP, SMTP, FTP, HTTPS 등이 포함되어 있음

### OSI 7계층과 TCP/IP
- OSI 7계층
- 전에는 프로토콜을 각 벤더들이 별도로 개발했기 때문에 호환되지 않는 시스템이나 애플리케이션이 많았음
- 하나의 프로토콜로 통합하고자 했던 노력으로 만들어진 것이 OSI 7계층
- 7개의 계층으로 모듈화 한 이유는 재사용 문제 때문: 하나로 만들면 재사용성이 떨어지고 이해하기 어려워짐

```
이름              데이터
Application       실제 데이터: 인간이 이해할 수 있는 데이터
Presentation      실제 데이터
Session           실제 데이터
Transport         Segments
Network           Packet
DataLink          Frames
Physical          Bits
```
- 2개 부분으로 분할
  - 5-7 계층: 상위 계층 - 애플리케이션 계층: 인간, 애플리케이션 개발자의 영역
  - 1-4 계층: 하위 계층 - Data Flow 계층: 기계, 네트워크 엔지니어의 영역
- TCP/IP 프로토콜 스택
  - 4개 계층으로 프로토콜을 정의
  - Application: OSI의 5-7 계층
  - Transport
  - Internet: OSI의 3계층
  - Network Access: OSI의 1, 2 계층
- 계층 별 기능을 설명할 때 OSI 7계층을 가지고 설명을 많이 함
### OSI 7계층 별 이해
- 1계층(물리 계층)
  - 물리적 연결과 관련된 정보
  - 장비로는 Hub, Repeater, Cable, Connector, Transiver(랜카드와 케이블을 연결해주는 장비), TAP(네트워크 모니터링이나 패킷 분석을 하기 위해서 전기 신호를 다른 장비로 복제해주는 장비) 등
- 2계층(데이터 링크 계층)
  - 전기 신호를 데이터 형태로 변환
  - 주소 정보를 정의하고 정확한 주소로 통신이 되도록 하는 역할을 수행
  - 1계층에서는 주소라는 개념이 존재하지 않지만 출발지 주소와 목적지 주소를 확인하고 자신에게 전송된 것인지 확인
  - 에러 탐지도 수행
  - 2계층 장비는 NIC(Network Interface Card)와 Switch
  - 사용하는 주소 체계는 MAC Address
  - 2계층 장비들은 MAC Address를 이해할 수 있는 장비
  - NIC 동작 방식: 전기 신호를 데이터 형태로 생성 후 목적지 MAC주소와 출발지 MAC 주소를 확인, 자신의 MAC주소 확인, 목적지 MAC주소와 자신의 MAC주소가 일치하면 데이터를 처리하고 다르면 데이터를 파기
  - Switch: 허브와 유사하게 여러 개의 포트로 구성
    - MAC주소 테이블을 가지고 있어서 통신을 하면 MAC 주소를 학습해서 테이블에 저장할 수 있음
    - 단말들이 통신할 때 포트를 적절히 필터링하고 정확한 포트로 포워딩
    - 허브는 어느 한 순간 하나의 장비만 전송이 가능하지만 Switch는 동시에 데이터 전송이 가능
- 3계층(네트워크 계층)
  - 논리적인 주소가 정의
  - 사용자가 환경에 맞게 변경할 수 있고 주소를 네트워크 주소 부분과 호스트 주소 부분으로 나누어서 할당할 수 있음
  - 3계층 장비가 라우터
  - IP를 이해해서 다른 네트워크를 찾아가는 장비임
- 4계층(전송 계층)
  - 데이터들이 정상적으로 잘 전송이 되는지 확인하는 역할
  - 데이터는 하나의 묶음으로 전송되지 않고 일정한 크기(Packet) 단위로 분할해서 보내게 되는데 중간에 퍂킷이 유실되거나 순서가 바뀔 수 있어 이러한 문제를 해결
  - 패킷을 만들 때 Sequence Number를 붙이고 받는 쪽에서는 ACK(Acknowledgement) Number를 전송
  - 컴퓨터 내에서 애플리케이션을 구분하기 위해서 port를 부여
  - 4계층에서 동작하는 장비는 Load Balancer와 Firewall: 장비라고 하기도 하고 Software라고 하기도 함
- 5계층(세션 계층)
  - 연결 해제와 연결 유지하는 역할
  - 에러 복구와 중단된 통신에 대한 재전송 수행
  - 연결 해제와 유지를 위해서 특별한 키를 발급해서 키를 가지고 실제 연결하는 컴퓨터를 구분
- 6계층(프레젠테이션)
  - 구문 변환, 데이터 압축, 인코딩과 디코딩을 수행
  - 데이터의 형식을 맞추는 계층
- 7계층(애플리케이션 계층)
  - 애플리케이션 프로세스를 정의하는 계층
  - OSI 전 계층을 수행하는 장비는 Gateway(Router를 Gateway로 보는 경우가 많음)

### 통신과정
- 데이터를 전송을 하게 되면 상위 계층에서 하위 계층으로 데이터를 전송
- 전송을 받는 쪽에서는 하위 계층에서 상위 계층으로 데이터를 전송
- 데이터를 보내는 과정을 Encapsulation 그리고 받는 과정을 Decapsulation이라고 함
- 보내는 쪽 
  - Data -> 4계층(4계층 헤더 + Data: Segment) -> 3계층(3계층 헤더 + 4계층 헤더+ 데이터: Packet) -> 2계층(2계층 헤더+3계층헤더+4계층헤더+데이터+FCS) -> 1계층(전기적 신호로 변환)
- 받는 쪽은 반대 과정
- MSS와 MTU
  - MSS(Maximum Segment Size): 4계층에서 사용할 수 있는 데이터의 최대 크기
  - MTU(Maximum Transmission Unit): 네트워크 계층에서 한 번에 보낼 수 있는 데이터의 최대 크기, 이더넷에서는 1500바이트